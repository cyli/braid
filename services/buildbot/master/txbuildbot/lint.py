from twisted.python import log
from buildbot.status.builder import WARNINGS
from buildbot.steps.shell import ShellCommand

try:
    import cStringIO
    StringIO = cStringIO
except ImportError:
    import StringIO

class LintStep(ShellCommand):
    """
    A L{ShellCommand} that generates summary information of errors generated
    during a build, and new errors generated vs. the most recent trunk build.

    @ivar worse: a L{bool} indicating whether this build is worse with respect
        to reported errors than the most recent trunk build.
    """
    flunkOnWarnings = True

    def createSummary(self, logObj):
        logText = logObj.getText()
        self.worse = self.processLogs(self.getPreviousLog(), logText)


    def processLogs(self, oldText, newText):
        currentErrors = self.computeErrors(newText)
        previousErrors = self.computeErrors(oldText)

        self.addCompleteLog('%s errors' % self.lintChecker, '\n'.join(self.formatErrors(currentErrors)))
        self.formatErrors(previousErrors)

        newErrors = self.computeDifference(currentErrors, previousErrors)

        if newErrors:
            allNewErrors = self.formatErrors(newErrors)
            self.addCompleteLog('new %s errors' % self.lintChecker, '\n'.join(allNewErrors))

        return bool(newErrors)


    def computeErrors(self, logText):
        """
        @type logText: L{str}
        @param logText: output of lint command

        @return: L{dict} of L{set}s containing errors generated by lint, grouped by
            type
        """
        raise NotImplementedError("Must implement computeErrors for a Lint step")


    def formatErrors(self, newErrors):
        raise NotImplementedError("Must implement formatErrors for a Lint step")


    @staticmethod
    def computeDifference(current, previous):
        """
        Takes two dicts of sets, and computes the keywise difference.

        @type current: L{dict} of L{set}s
        @param current: errors from current build

        @type previous: L{dict} of L{set}s
        @param previous: errors from previous build

        @return
        @rtype L{dict}
        """
        new = {}
        for errorType in current:
            errors = (
                current[errorType] -
                previous.get(errorType, set()))
            log.msg("Found %d new errors of type %s" % (len(errors), errorType))
            if errors:
                new[errorType] = errors
        return new


    def getPreviousLog(self):
        """
        Gets the output of lint from the last build of trunk.

        @return: output of lint from last trunk build
        @rtype: L{str}
        """
        build = self._getLastBuild()
        if build is None:
            log.msg("Found no previous build, returning empty error log")
            return ""
        for logObj in build.getLogs():
            if logObj.step.name == self.name and logObj.name == 'stdio':
                text = logObj.getText()
                log.msg("Found error log, returning %d bytes" % (len(text),))
                return text
        log.msg("Did not find error log, returning empty error log")
        return ""


    def _getLastBuild(self):
        """
        Gets the L{BuildStatus} object of the most recent build of trunk.

        @return: most recent build of trunk
        @rtype: L{BuildStatus}
        """
        status = self.build.build_status
        number = status.getNumber()
        if number == 0:
            log.msg("last result is undefined because this is the first build")
            return None

        builder = status.getBuilder()
        targetRevision = self.getProperty('lint_revision')
        log.msg(format='Looking for build of %(revision)s', revision=targetRevision)

        count = 0
        lastTrunkBuild = None
        while count < 200 and number > 0:
            number -= 1
            build = builder.getBuild(number)
            if not build:
                continue
            branch = build.getProperty("branch")
            revision = build.getProperty('got_revision')
            if branch == "trunk":
                count += 1
                if revision == targetRevision:
                    log.msg(format="Found build %(number)d of trunk at %(revision)s",
                            number=number, revision=revision)
                    return build
                else:
                    log.msg(format="skipping build %(number)d of trunk at %(revision)s",
                            number=number, revision=revision)
                    try:
                        if revision and not lastTrunkBuild:
                            lastTrunkBuild = (revision, build)
                    except TypeError:
                        pass
            else:
                log.msg(format="skipping build %(number)d of branch %(branch)r at %(revision)s",
                        number=number, revision=revision, branch=branch)
        log.msg(format="falling off the end after searching %(count)d builds",
                count=status.getNumber() - number)
        if lastTrunkBuild:
            revision, build = lastTrunkBuild
            log.msg(format="Using build %(number)d at %(revision)s instead of %(targetRevision)s",
                        number=build.getNumber(), revision=revision, targetRevision=targetRevision)
            return build
        return None


    def evaluateCommand(self, cmd):
        if self.worse:
            return WARNINGS
        return ShellCommand.evaluateCommand(self, cmd)



class CheckDocumentation(LintStep):
    """
    Run Pydoctor over the source to check for errors in API
    documentation.
    """
    name = 'api-documentation'
    command = (
        'python',
        'bin/admin/build-apidocs',
        '.',
        'apidocs')
    description = ["checking", "api", "docs"]
    descriptionDone = ["api", "docs"]

    lintChecker = 'pydoctor'

    @staticmethod
    def computeErrors(logText):
        errors = {}
        for line in StringIO.StringIO(logText):
            try:
                # Mostly get rid of the trailing \n
                line = line.strip()
                if 'invalid ref to' in line:
                    key = 'invalid ref'
                    # Discard the line number since it's pretty unstable
                    # over time
                    fqpnlineno, rest = line.split(' ', 1)
                    fqpn, lineno = fqpnlineno.split(':')
                    value = '%s: %s' % (fqpn, rest)
                elif 'found unknown field on' in line:
                    key = 'unknown fields'
                    value = line
                else:
                    continue
                errors.setdefault(key, set()).add(value)
            except: # TODO: This should be handled better.
                log.err()
        return errors


    def formatErrors(self, newErrors):
        allNewErrors = []
        for errorType in newErrors:
            allNewErrors.extend(newErrors[errorType])
        allNewErrors.sort()
        return allNewErrors


    def getText(self, cmd, results):
        if results == WARNINGS:
            return ["api", "docs"]
        return ShellCommand.getText(self, cmd, results)



def filterTox(logText):
    """
    Filter out the tox output for lint tox envs -- where there's only one
    command.
    """
    toxStatus = 'NOT_STARTED'

    for line in StringIO.StringIO(logText):

        if " runtests: commands[0] | " in line:
            # Tox has started, further lines should be read
            toxStatus = 'STARTED'

        elif "ERROR: InvocationError:" in line:
            # Tox is finished
            toxStatus = 'FINISHED'

        elif '___ summary ___' in line:
            toxStatus = 'FINISHED'

        elif toxStatus == 'STARTED':
            yield line.strip("\n")
